// Generated by CoffeeScript 1.10.0
(function() {
  var Edges, MCL, Nodes;

  this.Edges = Edges = (function() {
    function Edges() {
      this.edges = {};
    }

    Edges.prototype.exists = function(source, sink) {
      var ref, ref1, ref2, ref3;
      return (((ref = this.edges) != null ? (ref1 = ref[source]) != null ? ref1[sink] : void 0 : void 0) != null) || (((ref2 = this.edges) != null ? (ref3 = ref2[source]) != null ? ref3[sink] : void 0 : void 0) != null);
    };

    Edges.prototype.add = function(source, sink) {
      if (this.exists(source, sink)) {
        this.edges[source][sink] = (this.edges[source][sink] + 1) | 0;
        return this.edges[sink][source] = (this.edges[sink][source] + 1) | 0;
      } else {
        return this.set(source, sink, 1);
      }
    };

    Edges.prototype.set = function(source, sink, cost) {
      var base, base1;
      if (!source || !sink) {
        throw Error("Invalid arguments. sourceId and sinkId is required.");
      }
      if (this.exists(source, sink)) {
        this.edges[source][sink] = cost | 0;
        return this.edges[sink][source] = cost | 0;
      } else {
        (base = this.edges)[source] || (base[source] = {});
        this.edges[source][sink] = cost | 0;
        (base1 = this.edges)[sink] || (base1[sink] = {});
        return this.edges[sink][source] = cost | 0;
      }
    };

    Edges.prototype.getSinkNodes = function(source) {
      var nodes, result;
      if (!this.edges[source]) {
        return [];
      } else {
        result = [];
        nodes = Object.keys(this.edges[source]);
        nodes.forEach((function(_this) {
          return function(sink) {
            if (_this.edges[source][sink] > 0) {
              return result.push(sink);
            }
          };
        })(this));
        return result;
      }
    };

    Edges.prototype.setSelfLoop = function(nodes) {
      return nodes.forEach((function(_this) {
        return function(source) {
          return nodes.forEach(function(sink) {
            var base;
            if (source === sink) {
              return (base = _this.edges[source])[sink] || (base[sink] = 1);
            }
          });
        };
      })(this));
    };

    Edges.prototype.getPendants = function(nodes) {
      var result;
      result = {};
      nodes.forEach((function(_this) {
        return function(source) {
          var costed, sink;
          costed = [];
          _.each(_this.edges[source], function(cost, sink) {
            if (nodes.indexOf(sink) === -1) {
              return;
            }
            if (source === sink) {
              return;
            }
            if (cost > 0) {
              return costed.push(sink);
            }
          });
          if (costed.length === 1) {
            sink = costed[0];
            result[sink] || (result[sink] = []);
            return result[sink].push(source);
          }
        };
      })(this));
      return result;
    };

    Edges.prototype.generateMatrix = function(nodes) {
      var result;
      result = {};
      nodes.forEach((function(_this) {
        return function(source) {
          return nodes.forEach(function(sink) {
            result[source] || (result[source] = {});
            return result[source][sink] = (_this.edges[source][sink] || 0) | 0;
          });
        };
      })(this));
      return result;
    };

    Edges.prototype.getIsolated = function(nodes) {
      var result;
      result = [];
      nodes.forEach((function(_this) {
        return function(source) {
          var costed;
          costed = [];
          _.each(_this.edges[source], function(cost, sink) {
            if (nodes.indexOf(sink) === -1) {
              return;
            }
            if (source === sink) {
              return;
            }
            if (cost > 0) {
              return costed.push(sink);
            }
          });
          if (costed.length === 0) {
            return result.push(source);
          }
        };
      })(this));
      return result;
    };

    Edges.prototype.avarageDegrees = function(nodes) {
      var total;
      total = 0;
      nodes.forEach((function(_this) {
        return function(source) {
          return _.each(_this.edges[source], function(cost, sink) {
            if (!_.contains(nodes, sink)) {
              return;
            }
            if (source === sink) {
              return;
            }
            if (cost > 0) {
              return total = total + 1;
            }
          });
        };
      })(this));
      return total / nodes.length;
    };

    return Edges;

  })();

  this.MCL = MCL = (function() {
    function MCL(option) {
      this.undirectedMode = (option != null ? option.undirectedMode : void 0) || true;
      this.expanses = (option != null ? option.expanses : void 0) || 2;
      this.inflates = (option != null ? option.inflates : void 0) || 2;
      this.selfLoop = (option != null ? option.selfLoop : void 0) || true;
      this.pruning = (option != null ? option.pruning : void 0) || true;
      this.loopLimit = (option != null ? option.loopLimit : void 0) || 100;
      this.pruned = {};
      this.isolated = [];
      this.nodes = new Nodes();
      this.edges = new Edges();
      this.workNodes = [];
      this.graph = {};
      this.result = {};
      this.resultCache = {};
      this.loopCount = 0;
      this.clustered = [];
      this.convergenced = false;
    }

    MCL.prototype.initializeWorkVariables = function() {
      this.pruned = {};
      this.isolated = [];
      this.workNodes = [];
      this.graph = {};
      this.result = {};
      this.resultCache = {};
      this.loopCount = 0;
      this.clustered = [];
      return this.convergenced = false;
    };

    MCL.prototype.addEdge = function(source, sink) {
      this.nodes.upsert(source);
      this.nodes.upsert(sink);
      return this.edges.add(source, sink);
    };

    MCL.prototype.setEdge = function(source, sink, cost) {
      this.nodes.upsert(source);
      this.nodes.upsert(sink);
      return this.edges.set(source, sink, cost);
    };

    MCL.prototype.clustering = function(node) {
      if (!_.isEmpty(node) && !this.nodes.exists(node)) {
        throw new Error("there is no node named '" + node + "'.");
      }
      this.initializeWorkVariables();
      this.workNodes = node ? this.edges.getSinkNodes(node) : this.nodes.all();
      if (this.pruning === true) {
        this.pruned = this.edges.getPendants(this.workNodes);
        this.workNodes = _.difference(this.workNodes, _.flatten(_.values(this.pruned)));
      }
      this.isolated = this.edges.getIsolated(this.workNodes);
      this.workNodes = _.difference(this.workNodes, this.isolated);
      if (this.selfLoop) {
        this.edges.setSelfLoop(this.workNodes);
      }
      this.graph = this.edges.generateMatrix(this.workNodes);
      this.normalize();
      while (this.convergenced === !true) {
        this.expansion();
        this.inflation();
        this.checkConvergence();
      }
      this.toFixedValues();
      this.divideCluster();
      return this.clustered;
    };

    MCL.prototype.normalize = function() {
      var totalCosts;
      totalCosts = {};
      return _.each(this.graph, (function(_this) {
        return function(edges, source) {
          return _.each(edges, function(cost, sink) {
            var base;
            totalCosts[sink] || (totalCosts[sink] = _.reduce(_.values(_this.graph), function(memo, elm) {
              return memo + elm[sink];
            }, 0));
            (base = _this.result)[source] || (base[source] = {});
            return _this.result[source][sink] = (cost / totalCosts[sink]) || 0;
          });
        };
      })(this));
    };

    MCL.prototype.expansion = function() {
      var iterator, result, results;
      iterator = 0;
      results = [];
      while (iterator < this.expanses) {
        result = {};
        this.workNodes.forEach((function(_this) {
          return function(row) {
            result[row] || (result[row] = {});
            return _this.workNodes.forEach(function(col) {
              var base;
              (base = result[row])[col] || (base[col] = 0);
              return _this.workNodes.forEach(function(i) {
                return result[row][col] += _this.result[row][i] * _this.result[i][col];
              });
            });
          };
        })(this));
        this.result = result;
        results.push(iterator++);
      }
      return results;
    };

    MCL.prototype.inflation = function() {
      var iterator, result, results, totalCosts;
      iterator = 0;
      results = [];
      while (iterator < this.inflates) {
        result = {};
        this.workNodes.forEach((function(_this) {
          return function(row) {
            result[row] || (result[row] = {});
            return _this.workNodes.forEach(function(col) {
              return result[row][col] = _this.result[row][col] * _this.result[row][col];
            });
          };
        })(this));
        totalCosts = {};
        _.each(result, (function(_this) {
          return function(edges, source) {
            return _.each(edges, function(cost, sink) {
              totalCosts[sink] || (totalCosts[sink] = _.reduce(_.values(result), function(memo, edges) {
                return memo + edges[sink];
              }, 0));
              result[source] || (result[source] = {});
              return result[source][sink] = (cost / totalCosts[sink]) || 0;
            });
          };
        })(this));
        this.result = result;
        results.push(iterator++);
      }
      return results;
    };

    MCL.prototype.checkConvergence = function() {
      this.loopCount++;
      if (this.workNodes.length === 2) {
        this.convergenced = true;
        this.workNodes.forEach((function(_this) {
          return function(source) {
            return _this.workNodes.forEach(function(sink) {
              return _this.result[source][sink] = 0;
            });
          };
        })(this));
        this.clustered.push(this.workNodes);
      }
      if (this.loopCount > this.loopLimit) {
        this.convergenced = true;
        this.workNodes.forEach((function(_this) {
          return function(source) {
            return _this.workNodes.forEach(function(sink) {
              return _this.result[source][sink] = 0;
            });
          };
        })(this));
        this.clustered.push(this.workNodes);
      }
      if (_.isEqual(this.resultCache, this.result)) {
        return this.convergenced = true;
      } else {
        return this.resultCache = this.result;
      }
    };

    MCL.prototype.toFixedValues = function() {
      return this.workNodes.forEach((function(_this) {
        return function(sink) {
          return _this.workNodes.forEach(function(source) {
            return _this.result[sink][source] = _this.result[sink][source].toFixed(1) * 1;
          });
        };
      })(this));
    };

    MCL.prototype.divideCluster = function() {
      var divided;
      divided = [];
      this.workNodes.forEach((function(_this) {
        return function(source) {
          var subResult;
          subResult = {};
          _this.workNodes.forEach(function(sink) {
            var parameter;
            parameter = _this.result[source][sink];
            if (parameter > 0 && !_.contains(divided, sink)) {
              subResult[parameter] || (subResult[parameter] = []);
              subResult[parameter].push(sink);
              divided.push(sink);
              if (_this.pruning && _this.pruned[sink]) {
                return _this.pruned[sink].forEach(function(node) {
                  subResult[parameter].push(node);
                  return divided.push(node);
                });
              }
            }
          });
          if (!_.isEmpty(subResult)) {
            return _.each(subResult, function(nodes, param) {
              if (!_.contains(_this.clustered, nodes)) {
                return _this.clustered.push(nodes);
              }
            });
          }
        };
      })(this));
      this.isolated.forEach((function(_this) {
        return function(node) {
          return _this.clustered.push([node]);
        };
      })(this));
      return _.each(this.pruned, (function(_this) {
        return function(sinks, source) {
          var cluster;
          if (!_.contains(divided, source)) {
            cluster = [source].concat(sinks);
            _this.clustered.push(cluster);
            divided.push(source);
            return sinks.forEach(function(sink) {
              return divided.push(sink);
            });
          }
        };
      })(this));
    };

    return MCL;

  })();

  this.Nodes = Nodes = (function() {
    function Nodes() {
      this.nodes = {};
      this.id = 0;
    }

    Nodes.prototype.set = function(name) {
      if (!name) {
        throw Error("empty value is given.");
      }
      if (this.exists(name)) {
        throw new Error(name + " is already created node.");
      }
      this.id += 1;
      return this.nodes[name] = this.id;
    };

    Nodes.prototype.upsert = function(name) {
      if (this.exists(name)) {
        return name;
      }
      return this.set(name);
    };

    Nodes.prototype.size = function() {
      return Object.keys(this.nodes).length;
    };

    Nodes.prototype.exists = function(name) {
      return this.nodes[name] != null;
    };

    Nodes.prototype.all = function() {
      return Object.keys(this.nodes);
    };

    return Nodes;

  })();

}).call(this);
